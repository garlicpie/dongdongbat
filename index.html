<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Slot</title>
<style>
  :root{
    --bg:#000;
    --gold1:#fff89a; --gold2:#ffe14b; --gold3:#ffd100; --gold4:#c99600;
    --reelW:110px; --reelH:130px; --gap:14px;       /* 슬롯 조금 더 작게 */
    --boxRadius:12px;
  }
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:#fff;overflow:hidden;
    font-family:"Noto Sans","Noto Sans KR","Noto Color Emoji",ui-sans-serif,system-ui,Segoe UI,Roboto,sans-serif;
    display:grid;place-items:center;
  }
  .wrap{position:relative;width:100vw;height:100vh}

  /* 중앙 슬롯 캔버스(그림은 캔버스에서, 탭 영역은 화면 전체) */
  #slot{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);image-rendering:auto}

  /* 돈(숫자만) — 자리수별 전환을 위해 컨테이너 */
  .money-wrap{
    position:absolute;top:20px;left:50%;transform:translateX(-50%);
    display:flex;gap:2px;align-items:center;user-select:none;
    font-weight:1000;font-size:clamp(28px,6vw,52px);letter-spacing:.5px;
    background:linear-gradient(180deg,var(--gold1),var(--gold2) 40%,var(--gold3) 70%,var(--gold4));
    -webkit-background-clip:text;background-clip:text;color:transparent;
    text-shadow:0 2px 0 rgba(0,0,0,.55),0 10px 26px rgba(255,224,0,.28);
  }
  .digit{
    position:relative;display:inline-block;min-width:0.6em;text-align:center;
  }
  .digit .old,.digit .new{
    position:absolute;left:0;right:0;top:0;will-change:transform,opacity;
  }
  .digit .old{animation:fallOut .25s ease forwards}
  .digit .new{transform:translateY(-0.9em);opacity:0;animation:fallIn .25s ease forwards}
  @keyframes fallOut{from{transform:translateY(0);opacity:1}to{transform:translateY(0.9em);opacity:0}}
  @keyframes fallIn {from{transform:translateY(-0.9em);opacity:0}to{transform:translateY(0);opacity:1}}

  /* JACKPOT FX */
  .fx{ position:absolute;inset:0;pointer-events:none; }
  .jackpot{
    position:absolute;inset:0;display:grid;place-items:center;opacity:0;visibility:hidden;transition:opacity .25s;
  }
  .jackpot.show{opacity:1;visibility:visible}
  .jackpot .txt{
    font-size:clamp(52px,12vw,140px);font-weight:1000;color:#ff1a1a;letter-spacing:.02em;
    text-shadow:0 10px 36px rgba(255,0,0,.55),0 2px 0 #300;animation:thump .9s cubic-bezier(.2,1.2,.2,1) 2;
    font-family:"Noto Sans","Noto Sans KR",sans-serif;
  }
  @keyframes thump{0%{transform:scale(.82)}50%{transform:scale(1.12)}100%{transform:scale(1)}}
  .rainbow{
    position:absolute;inset:-25vmax;z-index:-1;opacity:0;filter:blur(10px) saturate(1.2);
    background:conic-gradient(from 0deg,red,orange,yellow,green,cyan,blue,violet,red);
    mask:radial-gradient(closest-side,rgba(255,255,255,.95),transparent 70%);
    transform:scale(.85) rotate(0deg);
  }
  .rainbow.show{ animation:spin 1.6s linear infinite, pulse 1.6s ease-in-out infinite alternate; opacity:.9 }
  @keyframes spin{to{transform:scale(1.05) rotate(360deg)}}
  @keyframes pulse{from{opacity:.6}to{opacity:.93}}

  /* 콘솔 입력 */
  .console{ position:absolute;left:50%;bottom:22px;transform:translateX(-50%);width:min(680px,92vw);display:none; }
  .console.show{display:block}
  .console input{
    width:100%;padding:12px 14px;border-radius:10px;border:1px solid #333;outline:none;color:#fff;background:#0d0d0d;
    box-shadow:0 6px 20px rgba(0,0,0,.5), inset 0 0 0 2px rgba(255,255,255,.03);
    font-size:16px;letter-spacing:.3px;
    font-family:"Noto Sans","Noto Sans KR",sans-serif;
  }

  /* DEV 패널: 슬롯을 가리지 않도록 좌하단 도킹(작게) */
  .dev{
    position:absolute;left:12px;bottom:12px;max-width:min(520px,44vw);max-height:36vh;overflow:auto;
    background:#0b0b0b;border:1px solid #2a2a2a;border-radius:12px;padding:10px 12px;color:#ddd;
    font: 12.5px/1.45 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    display:none; z-index:3;
    box-shadow:0 8px 28px rgba(0,0,0,.5);
  }
  .dev.show{display:block}
  .dev h3{margin:.2em 0 .4em;font-size:13.5px;color:#ffe14b;font-family:"Noto Sans","Noto Sans KR",sans-serif;}
  .dev table{width:100%;border-collapse:collapse;margin:6px 0 8px}
  .dev th,.dev td{border-bottom:1px solid #222;padding:4px 6px;text-align:left}
  .dev .muted{opacity:.7}
</style>
</head>
<body>
<div class="wrap" id="app" aria-label="tap anywhere">
  <canvas id="slot" width="400" height="150" aria-label="slot"></canvas>

  <!-- 돈 (자리수별 렌더링) -->
  <div class="money-wrap" id="moneyWrap" aria-live="polite"></div>

  <!-- FX -->
  <div class="fx">
    <div class="rainbow" id="rainbow"></div>
    <div class="jackpot" id="jackpot"><div class="txt">JACKPOT!</div></div>
  </div>

  <!-- 콘솔 -->
  <div class="console" id="console"><input id="cmd" type="text" spellcheck="false" autocomplete="off" placeholder="/777, /dev, /devoff"/></div>

  <!-- DEV -->
  <div class="dev" id="devPanel">
    <h3>DEV</h3>
    <div id="rules"></div>
    <div id="rtp" style="margin:6px 0 4px"></div>
    <div class="muted">Logs (latest 30)</div>
    <table id="logs"><thead><tr><th>time</th><th>sym</th><th>bet</th><th>payout</th><th>delta</th><th>bank</th><th>note</th></tr></thead><tbody></tbody></table>
  </div>
</div>

<script>
(()=> {
  /* ================= CONFIG (영문 표기만 노출) ================= */
  const CFG = {
    reels: 3,
    reelW: 110, reelH: 130, gap: 14,                // 요청: 조금 더 작게 + 리얼 박스는 캔버스에서 그림
    cost: 100,                                       // bet per spin (음수 허용)
    // 가중치(확률) — 값이 클수록 자주 등장
    weights: { "🍒":6, "🍋":6, "⭐":3, "7":1, "💎":2, "🔔":4, "🍀":5, "🍇":6 },
    // 배당(배수)
    pay3:    { "7":1000, "💎":200, "⭐":80, "🔔":30, "🍀":20, "🍒":10, "🍋":8, "🍇":6 },
    pay2:    { "7":25,   "💎":6,   "⭐":3,  "🔔":2,  "🍀":2,  "🍒":2,  "🍋":2, "🍇":2 },
    /* 스핀/정지 동작 */
    spinCellsPerSec: 18,       // 회전 속도(초당 셀 수) — 등속
    stopStagger: 420,          // 릴 정지 시작 간격(ms) — 좌→우 순차
    stopDuration: 900,         // 각 릴이 정지에 걸리는 시간(ms) — 모두 동일(요청사항)
    extraTurns: 2,             // 정지 시작 후 추가로 도는 바퀴 수(고정, 랜덤 X)
    cellPadRatio: 0.14         // 셀 안쪽 여백(이모지 작게 보이도록)
  };

  /* ================= STATE ================= */
  const el = {
    cvs: document.getElementById('slot'),
    app: document.getElementById('app'),
    moneyWrap: document.getElementById('moneyWrap'),
    console: document.getElementById('console'),
    cmd: document.getElementById('cmd'),
    jp: document.getElementById('jackpot'),
    rb: document.getElementById('rainbow'),
    dev: document.getElementById('devPanel'),
    rules: document.getElementById('rules'),
    rtp: document.getElementById('rtp'),
    logs: document.querySelector('#logs tbody'),
  };
  const ctx = el.cvs.getContext('2d');

  /* DPR/캔버스 크기 */
  function sizeCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const W = CFG.reelW*CFG.reels + CFG.gap*(CFG.reels-1);
    const H = CFG.reelH;
    el.cvs.style.width = W+'px'; el.cvs.style.height = H+'px';
    el.cvs.width = Math.floor(W*dpr); el.cvs.height = Math.floor(H*dpr);
    return dpr;
  }
  let DPR = sizeCanvas();
  window.addEventListener('resize', ()=>{ DPR=sizeCanvas(); drawStatic(); });

  /* SYMBOLS & SHEET (세로 시트, 정사각 셀) */
  const SYMBOLS = ["🍒","🍋","⭐","7","💎","🔔","🍀","🍇"];
  const IDX = Object.fromEntries(SYMBOLS.map((s,i)=>[s,i]));
  const N = SYMBOLS.length;

  function makeSheet(){
    const px = Math.max(220, Math.floor(CFG.reelH*1.9)); // 고해상도 → 축소
    const cnv = document.createElement('canvas'); cnv.width = px; cnv.height = px*N;
    const c = cnv.getContext('2d');
    c.textAlign='center'; c.textBaseline='middle';
    for(let i=0;i<N;i++){
      const cy = i*px + px/2;
      if(SYMBOLS[i]==="7"){
        c.font = `900 ${Math.floor(px*0.66)}px "Noto Sans","Noto Sans KR",sans-serif`;
        c.fillStyle='#fff';
        c.lineWidth = Math.max(2, px*0.02); c.strokeStyle='rgba(0,0,0,.45)';
        c.strokeText('7', px/2, cy);
        c.fillText('7', px/2, cy);
      }else{
        c.font = `${Math.floor(px*0.74)}px "Noto Color Emoji","Noto Sans",sans-serif`;
        c.fillText(SYMBOLS[i], px/2, cy);
      }
    }
    return {sheet:cnv, px};
  }
  const SPR = makeSheet();

  /* 릴(셀 단위 위치) */
  const reels = Array.from({length:CFG.reels}, ()=>({
    pos: Math.random()*N,            // 현재 위치(셀 단위, 소수 가능)
    startPos: 0, targetPos: 0,       // 정지 인터폴레이션용
    stopStart: null, stopEnd: null,  // 정지 구간 시간
    stopping:false, stopped:true
  }));

  let bank = 10000;             // 음수 허용
  let state = 'idle';           // idle | spinning | stopping
  let lastT = 0;
  let rAF = 0;
  let planIdx = null;           // 정지 시 확정할 결과(다시 누를 때 결정)
  let devMode = false;

  /* ==== MONEY (자리수별 애니메이션) ==== */
  function renderMoneyDigits(num){
    const s = num.toLocaleString();
    // 처음 렌더 or 길이가 바뀌면 전체 리빌드
    if(!el.moneyWrap.dataset.text || el.moneyWrap.dataset.text.length !== s.length){
      el.moneyWrap.innerHTML = '';
      for(const ch of s){
        const span = document.createElement('span');
        span.className='digit';
        span.textContent = ch;
        el.moneyWrap.appendChild(span);
      }
      el.moneyWrap.dataset.text = s;
      return;
    }
    // 자리수 비교 → 달라진 자리만 교체 애니메이션
    const prev = el.moneyWrap.dataset.text;
    const nodes = Array.from(el.moneyWrap.children);
    for(let i=0;i<s.length;i++){
      if(prev[i]===s[i]) continue;
      const cell = nodes[i];
      const old = document.createElement('span'); old.className='old'; old.textContent = prev[i];
      const neu = document.createElement('span'); neu.className='new'; neu.textContent = s[i];
      cell.innerHTML=''; cell.appendChild(old); cell.appendChild(neu);
      // 260ms 후 고정 텍스트로 교체
      setTimeout(()=>{ cell.textContent = s[i]; }, 260);
    }
    el.moneyWrap.dataset.text = s;
  }
  function setMoney(v, animate=true){
    const from = bank; bank = v;
    if(!animate){ renderMoneyDigits(bank); return; }
    // 빠른 계단상승 느낌: 차이가 작을수록 step=1, 클수록 step↑
    const diff = Math.abs(bank - from);
    const dir = bank>from ? 1 : -1;
    let cur = from;
    const t0 = performance.now();
    function step(now){
      const elapsed = now - t0;
      // 220~420ms 내에 수렴되도록 스텝 계산
      const targetDur = Math.min(420, Math.max(220, diff*2));
      const p = Math.min(1, elapsed/targetDur);
      // 지수 가속으로 속도감
      const eased = p*p;
      const est = from + Math.round((bank - from)*eased);
      // 최소 1씩은 진행
      if(est===cur && cur!==bank) cur += dir;
      else cur = est;
      renderMoneyDigits(cur);
      if(cur!==bank) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  /* ==== 배당 계산 / RTP ==== */
  function payoutFor(indices){
    const sym = indices.map(i=>SYMBOLS[i]);
    const counts = {}; sym.forEach(s=>counts[s]=(counts[s]||0)+1);
    let multi = 0;
    for(const s of Object.keys(counts)){ if(counts[s]===3){ multi = (CFG.pay3[s]||0); break; } }
    if(multi===0){ for(const s of Object.keys(counts)){ if(counts[s]===2){ multi = (CFG.pay2[s]||0); break; } } }
    return {multiplier:multi, symbols:sym};
  }
  function calcRTP(){
    const w = SYMBOLS.map(s=>CFG.weights[s]||0);
    const sum = w.reduce((a,b)=>a+b,0);
    const p = w.map(x=>x/sum);
    let rtp = 0;
    for(let i=0;i<N;i++) rtp += (CFG.pay3[SYMBOLS[i]]||0) * Math.pow(p[i],3);
    for(let i=0;i<N;i++) rtp += (CFG.pay2[SYMBOLS[i]]||0) * (3 * Math.pow(p[i],2) * (1-p[i]));
    return rtp;
  }

  /* ==== 결과 뽑기(정지 시점에 확정) ==== */
  function pickOutcome(forced=null){
    if(forced) return forced.slice();
    const bag = SYMBOLS.map(s=>({s,w:CFG.weights[s]}));
    const sum = bag.reduce((a,b)=>a+b.w,0);
    const pick = ()=>{
      let x = Math.random()*sum;
      for(const it of bag){ if((x-=it.w)<0) return IDX[it.s]; }
      return IDX[bag[bag.length-1].s];
    };
    return [pick(),pick(),pick()];
  }

  /* ==== 그림 도우미 ==== */
  function rrect(x,y,w,h,r){
    const k = Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+k,y);
    ctx.arcTo(x+w,y,x+w,y+h,k);
    ctx.arcTo(x+w,y+h,x,y+h,k);
    ctx.arcTo(x,y+h,x,y,k);
    ctx.arcTo(x,y,x+w,y,k);
    ctx.closePath();
  }

  function drawReel(i){
    const rw = Math.floor(CFG.reelW*DPR), rh = Math.floor(CFG.reelH*DPR), gap = Math.floor(CFG.gap*DPR);
    const totalW = rw*CFG.reels + gap*(CFG.reels-1);
    const x0 = Math.floor((el.cvs.width - totalW)/2) + i*(rw+gap);
    const y0 = Math.floor((el.cvs.height - rh)/2);
    const r = reels[i];

    // 외곽 박스 + 클립
    ctx.save();
    rrect(x0,y0,rw,rh,Math.floor(12*DPR));
    ctx.fillStyle='#101010'; ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,.06)'; ctx.lineWidth=2*DPR; ctx.stroke();
    ctx.clip();

    // 스프라이트 그리기 (정사각 소스 → 비율 유지, 중앙 배치)
    const pad = Math.floor(CFG.reelH*CFG.cellPadRatio)*DPR;
    const viewH = rh - pad*2;
    const s = Math.floor(Math.min(rw, viewH) * 0.76);  // 작게
    const dx = x0 + Math.floor((rw - s)/2);
    // 현재 셀 위치
    const off = ((r.pos%N)+N)%N;
    const base = Math.floor(off);
    const shift = (off - base)*CFG.reelH*DPR;

    for(let k=-1;k<=2;k++){
      const idx = (base + k + N) % N;
      const sy = idx * SPR.px;
      const dyTop = y0 + (k*CFG.reelH)*DPR - Math.floor(shift) + pad + Math.floor((viewH - s)/2);
      ctx.drawImage(SPR.sheet, 0, sy, SPR.px, SPR.px, dx, dyTop, s, s);
    }
    ctx.restore();
  }

  function drawAll(){
    ctx.clearRect(0,0,el.cvs.width,el.cvs.height);
    for(let i=0;i<reels.length;i++) drawReel(i);
  }

  /* ==== JACKPOT ==== */
  function showJackpot(){
    el.jp.classList.add('show'); el.rb.classList.add('show');
    setTimeout(()=>{ el.jp.classList.remove('show'); el.rb.classList.remove('show'); }, 1800);
  }

  /* ==== 루프 ==== */
  function loop(t){
    if(!lastT) lastT = t;
    const dt = Math.min(50, t - lastT)/1000; // sec
    lastT = t;

    let allStopped = true;
    const v = CFG.spinCellsPerSec * dt;

    for(let i=0;i<reels.length;i++){
      const r = reels[i];

      if(state==='spinning'){
        r.pos += v; r.stopped=false; allStopped=false;
      }else if(state==='stopping'){
        if(!r.stopping){                   // 아직 감속 시작 전
          if(t >= (r.stopStart||Infinity)){
            // 정지 구간 설정(고정 시간)
            r.stopping = true;
            r.startPos = r.pos;
            const cur = ((r.startPos%N)+N)%N;
            const idx = planIdx[i];
            const diff = (idx - cur + N) % N;
            const total = diff + CFG.extraTurns*N;
            r.targetPos = r.startPos + total;
            r.stopEnd = r.stopStart + CFG.stopDuration;
          }else{
            r.pos += v;
            allStopped=false;
          }
        }
        if(r.stopping){
          const p = Math.min(1, (t - r.stopStart) / CFG.stopDuration);
          // 부드러운 감속(고정 시간)
          const ease = 1 - Math.pow(1 - p, 3); // easeOutCubic
          r.pos = r.startPos + ease * (r.targetPos - r.startPos);
          if(p < 1){ r.stopped=false; allStopped=false; }
          else { r.pos = r.targetPos; r.stopped = true; }
        }
      }
    }

    drawAll();

    if(!allStopped){ rAF = requestAnimationFrame(loop); return; }
    // 모두 정지 → 정산
    rAF = 0; state='idle';
    settle();
  }

  /* ==== 입력: 화면 전체 탭 / Space / 콘솔 ==== */
  function startSpin(){
    if(state!=='idle') return;
    setMoney(bank - CFG.cost, true); // 음수 허용
    state='spinning'; lastT=0;
    if(!rAF) rAF = requestAnimationFrame(loop);
  }
  function beginStop(force777=false){
    if(state!=='spinning') return;
    // 결과는 "정지 버튼을 누른 순간" 확정
    planIdx = force777 ? [IDX['7'],IDX['7'],IDX['7']] : pickOutcome();
    state='stopping';
    const t0 = performance.now();
    reels.forEach((r,i)=>{ r.stopStart = t0 + CFG.stopStagger*i; r.stopping=false; });
  }

  // 전체 화면 탭 (콘솔/DEV 클릭은 제외)
  el.app.addEventListener('pointerdown', (e)=>{
    const ignore = e.target.closest('.console,.dev,#cmd');
    if(ignore) return;
    if(state==='idle') startSpin();
    else if(state==='spinning') beginStop(false);
  });
  // Space: 토글
  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space'){
      const isInput = document.activeElement && (document.activeElement.tagName==='INPUT' || document.activeElement.tagName==='TEXTAREA' || document.activeElement.isContentEditable);
      if(isInput) return;
      e.preventDefault();
      if(state==='idle') startSpin(); else if(state==='spinning') beginStop(false);
    }
    if(e.key==='/'){ e.preventDefault(); openConsole(); }
  });

  /* ==== 콘솔 명령 ==== */
  function openConsole(){ el.console.classList.add('show'); el.cmd.value='/'; el.cmd.focus(); el.cmd.setSelectionRange(el.cmd.value.length,el.cmd.value.length); }
  function closeConsole(){ el.console.classList.remove('show'); el.cmd.blur(); }

  el.cmd.addEventListener('keydown',(e)=>{
    if(e.key==='Escape'){ e.preventDefault(); closeConsole(); return; }
    if(e.key==='Enter'){ e.preventDefault(); const v = el.cmd.value.trim(); runCommand(v); el.cmd.value=''; closeConsole(); }
  });

  function runCommand(cmd){
    if(cmd==='/dev'){ devMode=true; updateDev(true); return; }
    if(cmd==='/devoff'){ devMode=false; updateDev(false); return; }
    if(cmd==='/777'){
      if(state==='idle'){ startSpin(); setTimeout(()=>{ if(state==='spinning') beginStop(true); }, 260); }
      else if(state==='spinning'){ beginStop(true); }
      return;
    }
  }

  /* ==== 정산/로그/DEV ==== */
  const logs = [];
  function settle(){
    const idx = reels.map(r => {
      let k = Math.round(r.pos) % N; if(k<0) k+=N; return k;
    });
    const info = payoutFor(idx);
    const bet = CFG.cost;
    const payout = bet * (info.multiplier||0);
    const delta = -bet + payout;
    setMoney(bank + payout, true);

    if(info.multiplier>=1000 && info.symbols.every(s=>s==='7')) showJackpot();

    logs.unshift({
      t:new Date().toLocaleTimeString(),
      sym:info.symbols.join(' '),
      bet,payout,delta,bank,
      note: (info.multiplier>=1000 && info.symbols[0]==='7' && info.symbols[1]==='7' && info.symbols[2]==='7')?'JACKPOT':''
    });
    if(logs.length>30) logs.pop();
    updateDev();
    planIdx=null;
  }

  function updateDev(toggle){
    if(toggle!==undefined) el.dev.classList.toggle('show', !!toggle);
    else el.dev.classList.toggle('show', devMode);
    if(!devMode) return;

    // 규칙/배당/확률
    const w = SYMBOLS.map(s=>({s, w:CFG.weights[s]}));
    const sum = w.reduce((a,b)=>a+b.w,0);
    const p = w.map(o=>o.w/sum);
    const pay3 = SYMBOLS.map(s=>`${s}×3:x${CFG.pay3[s]||0}`).join('  |  ');
    const pay2 = SYMBOLS.map(s=>`${s}×2:x${CFG.pay2[s]||0}`).join('  |  ');
    el.rules.innerHTML = `
      <div><b>weights</b> → ${SYMBOLS.map((s,i)=>`${s}:${CFG.weights[s]} (p=${p[i].toFixed(3)})`).join('  ·  ')}</div>
      <div style="margin-top:6px"><b>payout 3</b> → ${pay3}</div>
      <div><b>payout 2</b> → ${pay2}</div>
      <div class="muted" style="margin-top:4px">line: middle only, reels independent; randomness locked when you press stop</div>
    `;
    const rtp = calcRTP();
    el.rtp.textContent = `RTP≈ ${(rtp*100).toFixed(2)}% (bet=1 baseline)`;

    el.logs.innerHTML = logs.map(L=>(
      `<tr>
         <td class="muted">${L.t}</td>
         <td>${L.sym}</td>
         <td>${L.bet.toLocaleString()}</td>
         <td>${L.payout.toLocaleString()}</td>
         <td style="color:${L.delta>=0?'#69f169':'#ff6b6b'}">${L.delta>=0?'+':''}${L.delta.toLocaleString()}</td>
         <td>${L.bank.toLocaleString()}</td>
         <td class="muted">${L.note||''}</td>
       </tr>`
    )).join('');
  }

  /* ==== INIT ==== */
  function init(){
    renderMoneyDigits(bank);
    drawAll();
  }
  init();
})();
</script>
</body>
</html>
