<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Slot</title>
<style>
  :root{
    --bg:#000;
    --money1:#fff48a; --money2:#ffe24b; --money3:#ffd200; --money4:#c99a00; /* 더 노란 금색 */
    --reelW:160px; --reelH:180px; --gap:20px;
  }
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:#fff;overflow:hidden;
    font-family:ui-sans-serif,system-ui,Apple SD Gothic Neo,Segoe UI,Roboto,Apple Color Emoji,Noto Color Emoji,sans-serif;
    display:grid;place-items:center;
  }

  /* 중앙 정렬: 캔버스(슬롯)만 딱 중앙 */
  .wrap{position:relative;width:min(95vw,700px);height:min(80vh,520px)}
  #gl{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);}

  /* 상단 금액(숫자만) */
  .money{
    position:absolute;top:24px;left:50%;transform:translateX(-50%);
    font-weight:1000;font-size:clamp(28px,6vw,52px);letter-spacing:.5px;user-select:none;
    background:linear-gradient(180deg,var(--money1),var(--money2) 40%,var(--money3) 70%,var(--money4));
    -webkit-background-clip:text;background-clip:text;color:transparent;
    text-shadow:0 2px 0 rgba(0,0,0,.5), 0 8px 24px rgba(255,208,0,.25);
  }
  .money.count{ filter: drop-shadow(0 10px 24px rgba(255,224,0,.35)); }

  /* 손잡이(텍스트 없음) */
  .lever{
    position:absolute;right:8%;top:50%;transform:translateY(-50%);width:82px;height:240px;cursor:pointer;
    display:grid;place-items:center;
  }
  .lever .shaft{
    width:14px;height:150px;background:linear-gradient(90deg,#444,#aaa,#444);
    border-radius:9px;box-shadow:inset 0 0 8px rgba(0,0,0,.6);transform-origin:center top;transition:transform .15s;
  }
  .lever .knob{
    position:absolute;top:0;width:56px;height:56px;border-radius:50%;
    background:radial-gradient(55% 55% at 35% 30%,#ff4d4d,#900);
    box-shadow:inset 0 0 14px rgba(255,255,255,.35),0 12px 20px rgba(0,0,0,.6);
    transition:transform .15s;
  }
  .lever.pull .shaft{ transform:translateY(10px) rotate(6deg) }
  .lever.pull .knob{ transform:translateY(120px) }

  /* 잭팟 연출(영어만) */
  .fx{ position:absolute;inset:0;pointer-events:none; }
  .jackpot{
    position:absolute;inset:0;display:grid;place-items:center;opacity:0;visibility:hidden;transition:opacity .25s;
  }
  .jackpot.show{opacity:1;visibility:visible}
  .jackpot .txt{
    font-size:clamp(52px,12vw,140px);font-weight:1000;color:#ff1a1a;letter-spacing:.02em;
    text-shadow:0 10px 36px rgba(255,0,0,.55),0 2px 0 #300;animation:thump .9s cubic-bezier(.2,1.2,.2,1) 2;
  }
  @keyframes thump{0%{transform:scale(.82)}50%{transform:scale(1.12)}100%{transform:scale(1)}}

  .rainbow{
    position:absolute;inset:-25vmax;z-index:-1;opacity:0;filter:blur(10px) saturate(1.2);
    background:conic-gradient(from 0deg,red,orange,yellow,green,cyan,blue,violet,red);
    mask:radial-gradient(closest-side,rgba(255,255,255,.95),transparent 70%);
    transform:scale(.85) rotate(0deg);
  }
  .rainbow.show{ animation:spin 1.6s linear infinite, pulse 1.6s ease-in-out infinite alternate; opacity:.9 }
  @keyframes spin{to{transform:scale(1.05) rotate(360deg)}}
  @keyframes pulse{from{opacity:.6}to{opacity:.93}}

  /* 반응형: 작은 화면은 레버 제거(탭으로 조작) */
  @media (max-width:560px){ .lever{display:none} }
</style>
</head>
<body>
<div class="wrap" id="app">
  <canvas id="gl" width="540" height="190" aria-label="slot"></canvas>
  <div class="money" id="money">10,000</div>
  <div class="lever" id="lever">
    <div class="shaft"></div><div class="knob"></div>
  </div>

  <div class="fx">
    <div class="rainbow" id="rainbow"></div>
    <div class="jackpot" id="jackpot"><div class="txt">JACKPOT!</div></div>
  </div>
</div>

<script>
(() => {
  // ===== CONFIG =====
  const CFG = {
    reels: 3,
    cost: 100,
    jackpotOdds: 0.001,   // 0.1%
    jackpotPay: 100000,
    reelW: 160, reelH: 180, gap: 20,
    cellPx: 320,          // 스프라이트 한 칸 해상도 (고해상도 뒤 다운스케일)
    maxSpd: 2.8,          // cells/sec
    decel: 1.8,           // 감속 계수(클수록 빨리 서서히 멈춤)
    minSpin: 700,         // 최소 회전 유지(ms)
    stagger: 420,         // 릴 정지 시작 간격(ms)
    blurMax: 0.9          // 모션블러 최대 강도
  };

  // ===== DOM =====
  const el = {
    cvs: document.getElementById('gl'),
    money: document.getElementById('money'),
    lever: document.getElementById('lever'),
    rainbow: document.getElementById('rainbow'),
    jackpot: document.getElementById('jackpot'),
    app: document.getElementById('app')
  };

  // 중앙 배치 (캔버스 폭/높이 설정)
  function sizeCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const w = CFG.reelW*CFG.reels + CFG.gap*(CFG.reels-1);
    const h = CFG.reelH;
    el.cvs.style.width = w + 'px';
    el.cvs.style.height = h + 'px';
    el.cvs.width = Math.floor(w*dpr);
    el.cvs.height = Math.floor(h*dpr);
    return dpr;
  }
  let DPR = sizeCanvas();
  window.addEventListener('resize', ()=>{ DPR = sizeCanvas(); gl && gl.viewport(0,0,el.cvs.width,el.cvs.height); });

  // ===== SYMBOLS / SPRITESHEET =====
  // 이모지는 그대로, '7'은 텍스트로
  const SYMBOLS = ["🍒","🍋","⭐","7","💎","🔔","🍀","🍇"];
  const IDX_7 = SYMBOLS.indexOf("7");

  function makeSprite(){
    const N = SYMBOLS.length;
    const W = CFG.cellPx, H = CFG.cellPx*N;
    const cnv = document.createElement('canvas'); cnv.width=W; cnv.height=H;
    const ctx = cnv.getContext('2d');
    ctx.textAlign='center'; ctx.textBaseline='middle';

    for(let i=0;i<N;i++){
      const y = i*CFG.cellPx + CFG.cellPx/2;

      // 배경 투명, 약한 그림자
      ctx.save();
      // 심볼 그리기
      if (SYMBOLS[i] === "7"){
        ctx.font = `900 ${Math.floor(CFG.cellPx*0.72)}px Arial Black, Impact, system-ui, sans-serif`;
        ctx.fillStyle = '#ffffff';
        ctx.lineWidth = Math.max(2, CFG.cellPx*0.02);
        ctx.strokeStyle = 'rgba(0,0,0,.45)';
        ctx.strokeText('7', W/2, y);
        ctx.fillText('7', W/2, y);
      }else{
        // 이모지
        ctx.font = `${Math.floor(CFG.cellPx*0.78)}px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji`;
        ctx.fillText(SYMBOLS[i], W/2, y);
      }
      ctx.restore();
    }
    return cnv;
  }

  // ===== WebGL Setup =====
  const gl = el.cvs.getContext('webgl',{antialias:true,preserveDrawingBuffer:false});
  if(!gl){ alert('WebGL not supported'); return; }

  const VS = `
  attribute vec2 aPos;   // clip space (-1..1)
  attribute vec2 aUV;    // 0..1
  varying vec2 vUV;
  void main(){
    vUV = aUV;
    gl_Position = vec4(aPos,0.0,1.0);
  }`;

  const FS = `
  precision mediump float;
  uniform sampler2D uTex;
  uniform float uRows;    // total rows in spritesheet
  uniform float uVBase;   // top-of-window (0..1)
  uniform float uBlur;    // 0..1 motion blur amount
  varying vec2 vUV;

  // 세로 방향 모션블러: 속도 비례 오프셋 샘플
  vec4 sampleWithBlur(vec2 uv){
    // 9 taps 삼각 가중치
    const float TAPS = 9.0;
    const float HALF = 4.0;
    vec4 acc = vec4(0.0);
    float wsum = 0.0;
    for(float i=-HALF;i<=HALF;i+=1.0){
      float w = 1.0 - abs(i)/HALF;           // 삼각 가중
      float off = i * uBlur / uRows;         // 행 개수 기준 오프셋
      vec2 q = vec2(uv.x, fract(uv.y + off));
      acc += texture2D(uTex, q) * w;
      wsum += w;
    }
    return acc / wsum;
  }

  void main(){
    // 한 칸 높이는 1.0/uRows
    float v = fract(uVBase + vUV.y / uRows);
    vec2 uv = vec2(vUV.x, v);
    vec4 col = sampleWithBlur(uv);

    // 상하 가장자리 살짝 비네팅(깊이감)
    float edge = smoothstep(0.0, 0.12, vUV.y) * (1.0 - smoothstep(0.88, 1.0, vUV.y));
    col.rgb *= mix(0.9, 1.0, edge);
    gl_FragColor = col;
  }`;

  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src); gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s)); throw new Error('shader');
    }
    return s;
  }
  const prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, VS));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, FS));
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(prog)); throw new Error('link');
  }
  gl.useProgram(prog);

  // 풀스크린 삼각형(두 삼각형)
  const quad = new Float32Array([
    -1,-1, 0,0,   1,-1, 1,0,   1,1, 1,1,
    -1,-1, 0,0,   1,1, 1,1,   -1,1, 0,1
  ]);
  const vbo = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vbo); gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
  const stride = 4*4; // 4 floats per vertex (pos2+uv2)
  const aPos = gl.getAttribLocation(prog,'aPos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,stride,0);
  const aUV  = gl.getAttribLocation(prog,'aUV');  gl.enableVertexAttribArray(aUV);  gl.vertexAttribPointer(aUV,2,gl.FLOAT,false,stride,2*4);

  const uTex   = gl.getUniformLocation(prog,'uTex');
  const uRows  = gl.getUniformLocation(prog,'uRows');
  const uVBase = gl.getUniformLocation(prog,'uVBase');
  const uBlur  = gl.getUniformLocation(prog,'uBlur');

  // 텍스처 준비
  const sheet = makeSprite();
  const tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,sheet);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
  gl.uniform1i(uTex,0);
  gl.uniform1f(uRows, SYMBOLS.length);

  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  // ===== REEL STATE =====
  const reels = Array.from({length:CFG.reels}, (_,i)=>({
    pos: Math.random()*SYMBOLS.length,    // position in cells (continuous)
    spd: 0,                               // cells/sec
    stopAt: null,                         // ms timestamp stagger
    stopping:false,
    stopped:true
  }));
  let money = 10000;
  let state = 'idle'; // idle | spinning | stopping
  let startedAt = 0;
  let raf = 0;
  let forceJackpot = false;

  // ===== MONEY (숫자만) =====
  function animMoney(from,to,dur=600){
    if(from===to){ el.money.textContent = to.toLocaleString(); return; }
    const t0 = performance.now();
    el.money.classList.add('count');
    const ease = t=>1-Math.pow(1-t,3);
    function step(now){
      const p = Math.min(1,(now-t0)/dur);
      const v = Math.round(from+(to-from)*ease(p));
      el.money.textContent = v.toLocaleString();
      if(p<1) requestAnimationFrame(step);
      else el.money.classList.remove('count');
    }
    requestAnimationFrame(step);
  }
  function setMoney(v){ const prev = money; money = v; animMoney(prev, money); }

  // ===== INPUT =====
  function leverPullOnce(){ el.lever.classList.add('pull'); setTimeout(()=>el.lever.classList.remove('pull'),180); }
  function startSpin(){
    if(state!=='idle') return;
    if(money<CFG.cost) return; // 텍스트 제한으로 안내 생략
    leverPullOnce();
    setMoney(money - CFG.cost);
    startedAt = performance.now();
    state='spinning';
    reels.forEach(r=>{
      r.spd = CFG.maxSpd*(0.96+Math.random()*0.08);
      r.stopping=false; r.stopped=false; r.stopAt=null;
    });
    if(!raf) raf = requestAnimationFrame(loop);
  }
  function beginStop(force777=false){
    if(state!=='spinning') return;
    leverPullOnce();
    state='stopping';
    const t0 = performance.now();
    reels.forEach((r,i)=>{ r.stopAt = t0 + CFG.stagger*i; r.stopping=true; });
    if(force777){ forceJackpot = true; } // 777 강제
  }

  // 모바일: 슬롯 캔버스 탭으로 토글
  el.cvs.addEventListener('click', ()=>{ if(state==='idle') startSpin(); else if(state==='spinning') beginStop(); });

  // 레버 클릭으로 토글
  el.lever.addEventListener('click', ()=>{ if(state==='idle') startSpin(); else if(state==='spinning') beginStop(); });

  // 키보드: Space 토글 + "777" 치트
  let keyBuf = []; let lastKeyTime = 0;
  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space'){ e.preventDefault(); if(state==='idle') startSpin(); else if(state==='spinning') beginStop(); return; }
    if(/^[0-9]$/.test(e.key)){
      const now = performance.now();
      if(now-lastKeyTime>1500) keyBuf = [];
      keyBuf.push(e.key); lastKeyTime = now;
      if(keyBuf.slice(-3).join('')==='777'){
        // 자동 잭팟: 자동 회전+정지
        keyBuf=[];
        if(state==='idle'){
          startSpin();
          setTimeout(()=>beginStop(true), Math.max(220, CFG.minSpin));
        }else if(state==='spinning'){
          beginStop(true);
        } // stopping이면 대기
      }
    }
  });

  // ===== JACKPOT FX =====
  function showJackpot(){
    setMoney(money + CFG.jackpotPay);
    el.jackpot.classList.add('show');
    el.rainbow.classList.add('show');
    setTimeout(()=>{
      el.jackpot.classList.remove('show');
      el.rainbow.classList.remove('show');
    }, 1800);
  }

  // ===== RENDER =====
  function drawReel(i, vBase, blurAmt){
    // 각 릴의 뷰포트 설정 (캔버스 중앙)
    const totalW = CFG.reelW*CFG.reels + CFG.gap*(CFG.reels-1);
    const x0 = Math.floor((el.cvs.width - Math.floor(totalW*DPR))/2);
    const y0 = Math.floor((el.cvs.height - Math.floor(CFG.reelH*DPR))/2);
    const reelW = Math.floor(CFG.reelW*DPR);
    const reelH = Math.floor(CFG.reelH*DPR);
    const left = x0 + i*(reelW + Math.floor(CFG.gap*DPR));

    gl.viewport(left, y0, reelW, reelH);
    gl.uniform1f(uVBase, vBase);
    gl.uniform1f(uBlur, blurAmt);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }

  // ===== GAME LOOP =====
  function loop(now){
    let allStopped = true;
    const dt = (reels[0]._t ? (now - reels[0]._t)/1000 : 0.016);
    reels[0]._t = now;

    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    for(let i=0;i<reels.length;i++){
      const r = reels[i];

      // 스핀/감속
      if(state==='spinning'){
        if(now - startedAt < CFG.minSpin){ /* 유지 */ }
      }
      if(state==='stopping' && now >= (r.stopAt ?? Infinity)){
        // 감속 + 스냅 타겟
        r.spd = Math.max(0, r.spd - CFG.decel*dt);
        // 타겟 계산
        let targetIdx;
        if(forceJackpot){
          targetIdx = IDX_7;
        }else{
          // 가까운 정수 칸으로
          targetIdx = Math.round(r.pos) % SYMBOLS.length;
          if(targetIdx<0) targetIdx += SYMBOLS.length;
        }
        const curBase = r.pos;
        // 앞으로만 진행하도록 목표를 현재보다 같거나 큰 위치로 보정
        let tgt = Math.floor(curBase) + targetIdx;
        if(tgt < curBase) tgt += 1;
        // 천천히 목표에 붙이기
        r.pos = curBase + (tgt - curBase) * Math.min(1, dt*3.5);

        if(Math.abs(r.pos - tgt) < 0.002 && r.spd < 0.02){
          r.pos = tgt; r.spd = 0; r.stopped = true;
        }else{
          r.stopped = false;
        }
      }else if(state==='spinning'){
        r.pos += r.spd * dt;
        r.stopped = false;
      }

      if(!r.stopped) allStopped = false;

      // 화면용 vBase(0..1), 모션블러 강도
      const rows = SYMBOLS.length;
      const vBase = ((r.pos % rows)+rows)/rows % 1;
      const blurAmt = Math.min(CFG.blurMax, r.spd / (CFG.maxSpd*0.9)) * 0.9;
      drawReel(i, vBase, blurAmt);
    }

    if(!allStopped){ raf = requestAnimationFrame(loop); return; }

    // 모두 정지
    raf = 0; state='idle';

    // 결과 판정: 0.1% 잭팟 or 777
    const idxs = reels.map(r=>{
      let k = Math.round(r.pos) % SYMBOLS.length; if(k<0) k += SYMBOLS.length; return k;
    });

    const is777 = idxs.every(k => k===IDX_7);
    let jackpot = is777;
    if(!jackpot && Math.random() < CFG.jackpotOdds){ jackpot = true; }

    if(jackpot){ showJackpot(); }

    // 치트 완료 후 해제
    forceJackpot = false;
  }

  // 초기 렌더(정지 화면)
  (function initOnce(){
    gl.viewport(0,0,el.cvs.width,el.cvs.height);
    // 첫 프레임 그리기
    reels.forEach(r=>{ r.spd = 0; r.stopped = true; });
    gl.uniform1f(uVBase, 0.0);
    gl.uniform1f(uBlur, 0.0);
    for(let i=0;i<reels.length;i++){
      const rows = SYMBOLS.length;
      const vBase = ((reels[i].pos % rows)+rows)/rows % 1;
      drawReel(i, vBase, 0.0);
    }
    el.money.textContent = money.toLocaleString();
  })();

})();
</script>
</body>
</html>
